# 3. AI 시스템의 협업 방식: 서버, 클라이언트, 호스트 앱, 그리고 '만능 번역기' Transport

지난 2편에서는 MCP의 언어(JSON-RPC)와 기본 대화법(`tools/list`, `tools/call`), 그리고 이를 흉내 내는 초간단 응답기(서버)를 만들어보았습니다.

**[2편 다시보기: 소통 문법(JSON-RPC)과 기본 대화 + 초간단 응답기 만들기](part2.md)**

이제 이 간단한 응답기를 넘어, 실제 MCP 기반 AI 시스템이 어떻게 여러 요소들의 협업으로 동작하는지 그 구조를 살펴보겠습니다. 마치 오케스트라처럼 각자의 역할이 중요합니다!

### 1. MCP 시스템의 연주자들

#### ① MCP 서버: "전문 연주자 / 도구 전문가"
* **역할:** 특정 악기(외부 도구, API, 데이터 등)를 다루는 전문가입니다. MCP라는 표준 악보(프로토콜)를 읽고, 요청받은 대로(예: `tools/call`) 악기를 연주(기능 실행)하고 그 소리(결과)를 돌려줍니다.
* **특징:** 이 연주자는 전체 곡의 흐름(사용자 의도)이나 지휘자(호스트 앱)의 큰 그림까지는 알 필요가 없을 수 있습니다. 주어진 악보대로 정확히 연주하는 것이 중요합니다.

#### ② MCP 클라이언트: "악보 전달 및 소통 담당자"
* **역할:** 지휘자(호스트 앱)의 지시를 받아 표준 악보(MCP 요청)를 각 연주자(MCP 서버)에게 정확히 전달하고, 연주 결과(MCP 응답)를 다시 지휘자에게 보고하는 역할을 합니다. MCP 표준 통신 방법을 잘 알고 있습니다.
* **위치:** 보통 지휘자(호스트 앱) 바로 옆에서 보조하는 역할(라이브러리/SDK 형태)을 합니다.

#### ③ 호스트 앱 (Host App): "지휘자 & 총괄 프로듀서"
* **역할:** **가장 중요!** 오케스트라 전체를 이끄는 지휘자이자 공연의 총괄 프로듀서입니다. 사용자와 직접 소통하며, 어떤 곡(사용자 요청)을 어떻게 연주할지(작업 흐름) 결정하고 각 파트(LLM, MCP 클라이언트/서버)를 조율합니다.
* **주요 임무:**
    1. 관객(사용자)의 요청(질문/명령)을 접수합니다.
    2. 악곡 해석가(LLM)와 상의하여 요청을 분석하고 어떤 악기(도구)가 필요한지 파악합니다.
    3. 필요시, 소통 담당자(MCP 클라이언트)를 통해 연주자(MCP 서버)에게 "어떤 악기 다룰 줄 아세요?" (`tools/list`)라고 미리 물어볼 수 있습니다.
    4. 악곡 해석가(LLM)가 특정 악기 연주(도구 호출)를 제안하면, 소통 담당자(MCP 클라이언트)에게 지시하여 해당 연주자(MCP 서버)에게 연주(실행)를 요청합니다 (`tools/call`).
    5. 연주 결과(도구 결과)를 보고받아, 다시 악곡 해석가(LLM)에게 전달하여 최종적인 곡의 표현(자연어 답변)을 완성하게 합니다.
    6. 완성된 연주(답변)를 관객(사용자)에게 들려줍니다.
* **핵심:** **모든 지능적인 판단, 의사 결정, 전체 흐름 제어는 지휘자(호스트 앱)의 역할**입니다. MCP는 연주자들과 소통하는 표준화된 방법(악보/프로토콜)을 제공할 뿐입니다.

#### ④ LLM: "악곡 해석가 & 수석 연주자"
* **역할:** 악보(사용자 요청)를 깊이 이해하고 해석하며, 어떤 악기(도구)가 필요한지 지휘자(호스트 앱)에게 조언하고, 다른 연주자(MCP 서버)의 연주 결과(도구 결과)를 바탕으로 최종적인 아름다운 선율(자연어 답변)을 만들어내는 핵심적인 역할을 합니다.

### 2. 언어 장벽을 넘어서! '만능 번역기' Transport 인터페이스

그런데 만약, 아주 뛰어난 연주자(기존 API 또는 로컬 기능)가 있는데 MCP라는 표준 악보(프로토콜)를 읽을 줄 모른다면 어떻게 할까요? 그 연주자를 위해 MCP 서버를 새로 만들어야만 할까요?

**아닙니다!** 이때 등장하는 것이 바로 **`Transport` 인터페이스** 라는 '만능 번역기'입니다.

* **개념:** `Transport`는 MCP 클라이언트와 실제 도구/서비스(백엔드) 사이에서 통역사 역할을 해주는 약속(인터페이스)입니다.
* **동작 방식:**
    1. MCP 클라이언트는 항상 **표준 MCP 악보**(JSON-RPC 요청)를 `Transport` 번역기에게 건넵니다.
    2. `Transport` 번역기는 이 표준 악보를 받아서, 실제 연주자(백엔드 서비스)가 **알아들을 수 있는 방식** (예: 그 연주자만 이해하는 손짓 발짓 - 특정 API 호출 방식, 내부 함수 호출 등)으로 **번역**하여 전달합니다.
    3. 연주자의 연주 결과(백엔드 응답)를 받으면, 다시 그것을 **표준 MCP 악보 형식**(JSON-RPC 응답)으로 **번역**하여 MCP 클라이언트에게 돌려줍니다.
* **놀라운 유연성:** 이 '번역기' 덕분에, 기존에 만들어진 어떤 형태의 서비스나 기능이라도 **원래 모습을 바꿀 필요 없이** MCP 시스템에 연결할 수 있습니다! 번역 규칙은 `Transport` 구현 안에 담겨 있으며, 보통 클라이언트 측(호스트 앱)에서 이 번역기를 관리합니다.

### 정리 및 다음 편 예고

이번 편에서는 MCP 시스템이 서버, 클라이언트, 호스트 앱, LLM이라는 역할 분담과 협업을 통해 동작하며, 특히 **호스트 앱의 지휘자 역할**이 핵심임을 알아보았습니다. 또한 **Transport 인터페이스**라는 '만능 번역기'를 통해 기존의 어떤 도구나 서비스도 유연하게 MCP 생태계에 통합될 수 있다는 점을 확인했습니다.

이제 MCP 시스템의 전체적인 구조와 유연성까지 이해했으니, 다음 **4편**에서는 MCP가 제공하는 **핵심적인 가치(표준화!)** 를 다시 한번 강조하고, 이와 비교되는 **Function Calling(Tool Calling)** 과의 관계를 명확히 하며, MCP가 모든 것을 해결해주지 못하는 이유, 즉 **현실적인 한계점**에 대해 솔직하게 이야기해보겠습니다.

MCP의 진짜 매력과 함께 알아두어야 할 점은 무엇일까요? 다음 편에서 그 속내를 들여다봅니다! 