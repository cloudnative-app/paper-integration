# 2. 소통 문법(JSON-RPC)과 기본 대화 + 초간단 응답기 만들기

지난 1편에서는 MCP를 LLM과 외부 도구가 소통하는 '공용어'에 비유하며, 표준화된 소통 방식의 중요성을 이야기했습니다.

**[1편 다시보기: AI 도구 연결, '표준 규격'이 필요한 이유! MCP란?](part1.md)**

이번 2편에서는 이 '공용어'의 구체적인 문법 규칙(JSON-RPC)을 배우고, 가장 기본적인 두 가지 대화 패턴(`tools/list`, `tools/call`)을 익혀보겠습니다. 그리고 이 대화를 실제로 주고받는 아주 간단한 '응답기'(서버)를 만들어보는 실습 시간도 갖겠습니다!

### 1. MCP 공용어 문법: JSON-RPC 2.0

MCP가 사용하는 소통 문법의 이름은 **JSON-RPC 2.0** 입니다. 핵심만 간단히 알아보죠.

* **JSON 형식 사용:** 데이터를 `{ "이름": "값" }` 형태로 표현하는, 사람이 읽기 쉬운 JSON 방식을 사용합니다.
* **원격 기능 호출(RPC):** 네트워크 너머 다른 컴퓨터(서버)에 있는 기능을 요청하고 결과를 받는 방식입니다.
* **요청(Request)과 응답(Response):** 모든 대화는 요청과 그에 대한 응답으로 이루어집니다.
    * **요청 메시지:** "무엇을(`method`) 해달라"는 요청과 함께, 필요 정보(`params`) 및 고유 식별표(`id`)를 담아 보냅니다.
    * **응답 메시지:** 요청받은 작업의 결과(`result`) 또는 오류 정보(`error`)를 요청 식별표(`id`)와 함께 돌려줍니다.

### 2. 기본 대화 1: `tools/list` (어떤 도구 사용 가능해요?)

MCP 클라이언트(AI 앱)가 MCP 서버(도구 제공자)에게 "당신이 제공할 수 있는 도구들의 이름과 사용 설명서를 보내주세요"라고 묻는 표준 질문입니다. 마치 식당에 가서 "여기서 주문 가능한 메뉴판 좀 주세요"라고 하는 것과 같습니다.

* **요청:** `method` 필드에 `"tools/list"` 를 담아 보냅니다. (`params`는 보통 없음)
* **성공 응답:** `result` 필드 안에 `tools` 라는 배열(리스트)이 담겨 옵니다. 이 배열에는 사용 가능한 각 도구의 이름(`name`), 설명(`description`), 그리고 사용법(`inputSchema` - 어떤 입력값이 필요한지에 대한 설명서) 정보가 들어있습니다.

### 3. 기본 대화 2: `tools/call` (이 도구, 이렇게 사용해주세요!)

클라이언트가 서버에게 "메뉴판에서 봤던 '이 도구'를, '이러한 재료(입력값)'를 넣어서 실행시켜 주세요"라고 구체적으로 요청하는 표준 방식입니다. "A 메뉴를 덜 맵게 조리해주세요"라고 주문하는 것과 비슷하죠.

* **요청:** `method` 필드에 `"tools/call"` 을, `params` 필드 안에는 실행할 도구 이름(`name`)과 필요한 입력값들(`arguments`)을 담아 보냅니다. (`arguments`의 구조는 `tools/list` 응답의 `inputSchema`에 정의된 형식을 따라야 합니다.)
* **성공 응답:** `result` 필드 안에 도구 실행 결과(`content`)가 담겨 옵니다. 결과는 텍스트, 숫자, 이미지 등 다양할 수 있습니다.

### 🔧 실습 가이드: 초간단 MCP '응답기' 만들기 (Python + Flask)

이론만으로는 감이 잘 안 오죠? `tools/list`와 `tools/call` 요청을 받으면 정해진 답변만 해주는 아주 간단한 '응답기'(서버)를 직접 만들어 봅시다. **실제 AI 기능은 없지만, MCP 프로토콜 통신이 어떻게 이루어지는지 체험하는 데 목적이 있습니다.**

#### 실습 코드 및 실행/테스트 방법

1. Flask 라이브러리를 설치합니다 (`pip install Flask`).
2. 제공된 `simple_mcp_server.py` 코드를 저장합니다.
3. 터미널에서 `python simple_mcp_server.py` 로 서버를 실행합니다.
4. 다른 터미널에서 `curl` 명령어를 사용하여 `tools/list`와 `tools/call` 요청을 직접 보내보고, 서버가 JSON-RPC 형식으로 응답하는 것을 확인합니다.

```bash
# tools/list 테스트
curl -X POST -H "Content-Type: application/json" -d '{"jsonrpc": "2.0", "id": "1", "method": "tools/list"}' http://127.0.0.1:5000/rpc

# tools/call (get_weather) 테스트
curl -X POST -H "Content-Type: application/json" -d '{"jsonrpc": "2.0", "id": "2", "method": "tools/call", "params": {"name": "get_weather", "arguments": {"city": "부산"}}}' http://127.0.0.1:5000/rpc
```

### 정리 및 다음 편 예고

이번 편에서는 MCP의 기본 소통 문법인 JSON-RPC와 핵심 대화 패턴 `tools/list`, `tools/call`을 배우고, 간단한 응답기(서버)를 직접 만들어 통신을 체험해봤습니다. MCP가 어떤 식으로 메시지를 주고받는지 조금은 감이 잡히셨기를 바랍니다.

하지만 실제 AI 시스템은 이 응답기처럼 단순하지 않습니다. 이 응답기(MCP 서버)에게 요청을 보내는 **클라이언트**는 어디에 있으며, 이 모든 과정을 지휘하고 **LLM과 연동하는 주체(호스트 앱)** 는 어떤 역할을 할까요? 그리고 기존 서비스를 MCP 방식으로 쉽게 연결해주는 **'마법의 어댑터'(Transport 인터페이스)** 는 또 무엇일까요?

다음 **3편**에서는 MCP 시스템을 이루는 **주요 역할들(서버, 클라이언트, 호스트 앱)** 을 더 깊이 파헤치고, MCP의 유연성을 극대화하는 **Transport 인터페이스**의 비밀을 알아보겠습니다! 기대해주세요! 